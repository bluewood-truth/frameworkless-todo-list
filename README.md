# Frameworkless TodoList

[TodoMVC Template](https://github.com/tastejs/todomvc-app-template)을 기반으로 <프레임워크 없는 프론트엔드 개발> 서적을 공부하며 TodoList를 만듭니다.

## 1. 렌더링

### 순수 함수 컴포넌트

- 순수 함수로 컴포넌트를 구현한다.
  1. `cloneNode` 메서드로 대상 엘리먼트를 복제
  2. 복제한 엘리먼트의 innerHTML을 `state`에 따라 생성한 html string으로 교체
  3. 이를 상위 엘리먼트부터 하위 엘리먼트로 순차적으로 수행한 후 마지막에 실제 DOM과 교체
- 렌더링 최적화를 위해 [requestAnimationFrame](https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame)의 콜백 내에서 DOM을 조작한다.

### 레지스트리

- 레지스트리를 통해 렌더링이 필요한 엘리먼트와 컴포넌트 함수를 연결한다.
  -  HTML상에는 `data-componet` 프로퍼티로 필요한 컴포넌트의 이름을 명시하고, `registry` 객체에는 컴포넌트 이름을 키로, 컴포넌트 함수를 값으로 등록한다.
  - 컴포넌트 함수를 `renderWrapper` 고차함수로 래핑하여 `data-component` 프로퍼티를 가진 엘리먼트에 필요한 컴포넌트 함수를 `registry`에서 찾아 적용하게 한다.

### diff 알고리즘

- 위 과정을 통해 생성한 가상 DOM은 실제 DOM과 diff 알고리즘을 통해 비교하여 교체를 최소한으로 한다. 과정은 다음과 같다.
  - 파라미터로 (실제) 부모 노드, 실제 노드, 가상 노드를 받는다.
  - 가상 노드가 존재하지 않으면 실제 노드를 제거한다.
  - 가상 노드가 존재하면 부모 노드에 추가한다.
  - 실제 노드와 가상 노드 둘 다 존재하면 변경 여부를 체크하고 교체한다. 변경 여부는 다음 사항을 체크한다.
    - 두 노드의 어트리뷰트의 수가 다를 경우
    - 두 노드의 각 어트리뷰트의 값이 하나라도 다를 경우
    - 두 노드에게 자식 엘리먼트가 없고 `textContent`가 일치하지 않는 경우
    - 위 사항에 해당하지 않으면 해당 노드는 변경되지 않았다고 판단한다.
  - 실제 노드와 가상 노드 모두 존재하고 변경되지도 않았다면, 두 노드의 자식 노드들에 대해 이 과정을 재귀적으로 수행한다. 따라서 실제 노드와 가상 노드가 모두 정의되지 않은 경우는 존재하지 않는다.

## 2. DOM 이벤트 관리

### YANGI 원칙

>  당신이 필요하다고 예측할 때가 아니라 실제로 필요할 때 구현하라.

- 가장 중요한 기능에 초점을 맞춰 개발하고 이후 추가적인 요구가 생기면 이에 따라 아키텍처를 지속적으로 발전시켜 나간다.

### 템플릿 포팅

- 기존의 방식은 todo 문자열을 생성하고 이를 합쳐 부모 노드의 `innerHTML`에 추가했다. 하지만 문자열에는 이벤트 핸들러를 추가할 수 없다. 따라서 문자열을 다루는 부분을 DOM노드를 다루는 것으로 변경해야 한다.
- `<template>`는 JavaScript를 통해 인스턴스를 생성할 수 있는 HTML 코드를 담기 위한 태그다. 이를 이용해 손쉽게 노드를 생성할 수 있다.
- 우선 todo 컴포넌트에 `<template>`을 적용하고 이후 app 컴포넌트를 새로 만들어 여기에도 적용한다. 이를 통해 템플릿 기술을 전체 애플리케이션으로 확장할 수 있다.

### 기본 이벤트 처리 아키텍처

- 모든 이벤트 다음에 상태를 조작한 후 새로운 상태로 메인 렌더링 함수를 호출한다.

  > 초기 상태 → 렌더링 → 이벤트 → 새로운 상태 → 렌더링 → ...

- 상태를 조작하는 함수를 `events` 객체에 정의한 후 `events` 객체를 registry에 추가한다. 이를 통해 모든 컴포넌트에서 `events` 객체에 접근할 수 있게 된다.
- todo 항목을 삭제하는 핸들러는 리스트 엘리먼트에 추가하여 이벤트 위임을 할 수 있다. 버튼 하나하나에 핸들러를 추가하는 것에 비해 성능과 메모리 사용성을 개선할 수 있다.

